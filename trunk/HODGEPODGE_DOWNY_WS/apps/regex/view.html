<div id="condition">
	<ul>
		<li><input type="checkbox" id="toolG" checked="checked" /><label for="toolG">全局</label></li>
		<li><input type="checkbox" id="toolI" /><label for="toolI">不区分大小写</label></li>
		<li><input type="checkbox" id="toolM" /><label for="toolM">对^$前后换行也支持</label></li>
		<li><input type="checkbox" id="toolS" /><label for="toolS">符号.匹配所有</label></li>
	</ul>
	<ul style="float:right;">
		<li><input type="checkbox" checked="checked" id="highSyntax" /><label for="highSyntax">对正则着色</label></li>
		<li><input type="checkbox" checked="checked" id="highMatch" /><label for="highMatch">对匹配结果着色</label></li>
		<li><input type="checkbox" id="invertMatch" /><label  for="invertMatch">对无匹配结果着色</label></li>
	</ul>
</div>
<div id="mainbody">
	<div class="smartField" id="search">
		<textarea spellcheck="false" tabindex="1" rows="3" cols="100" id="searchText" style="height:155px;width:860px;"></textarea>
	</div>
	<div class="smartField" id="input" style="height:387px;">
		<textarea spellcheck="false" tabindex="2" rows="10" cols="100" id="inputText" style="height:385px;width:860px;"></textarea>
	</div>
</div>
{literal}
<style type="text/css">
	.app td,th{border:1px solid #C0C0C0;border-collapse:collapse;padding:5px;}
	.app table{border-collapse:collapse;border:1px solid #C0C0C0;margin:0 auto;}
	.app .menu-list{z-index:5}
	.app #mainbody{padding-top:10px;padding-bottom:10px;}
	.app #condition{margin-bottom:20px;}
	.app #condition ul li{margin-right:20px;float:left;list-style:none;}
	.app #condition ul li label{margin-left:5px;}
	.app #search{height:180px;width:99.75%;}
	.app #input{height:375px;margin-top:10px;width:99.75%;}
	.app .smartField{border:1px solid #CCCCCC;overflow:auto;position:relative;}
	.app .smartField pre,.smartField textarea{width:100%;padding:0;margin:0;font:100% "courier new",monospace;}
	.app .smartField pre{text-align:left;color:#F9F9F9;z-index:1;}
	.app .smartField textarea{background:none repeat scroll 0 0 transparent;border:0 none;height:100%;overflow:hidden;position:absolute;left:0px;top:0px;z-index:2;}
	.app b,i,u{font-style:normal;font-weight:normal;text-decoration:none;}
	.app #input b{background:none repeat scroll 0 0 #FFF000;color:#FFF000;}
	.app #input i{background:none repeat scroll 0 0 #80C0FF;color:#80C0FF;}
	.app #search b{background:none repeat scroll 0 0 #AAD1F7;color:#AAD1F7;}
	.app #search i{background:none repeat scroll 0 0 #F9CA69;color:#F9CA69;}
	.app #search i b{background:none repeat scroll 0 0 #F7A700;color:#F7A700;}
	.app #search i u{background:none repeat scroll 0 0 #EFBA4A;color:#EFBA4A;}
	.app #search b.g1{background:none repeat scroll 0 0 #D2F854;color:#D2F854;}
	.app #search b.g2{background:none repeat scroll 0 0 #9EC70C;color:#9EC70C;}
	.app #search b.g3{background:none repeat scroll 0 0 #ECC9F7;color:#ECC9F7;}
	.app #search b.g4{background:none repeat scroll 0 0 #54B70B;color:#54B70B;}
	.app #search b.g5{background:none repeat scroll 0 0 #B688CF;color:#B688CF;}
	.app #search b.err{background:none repeat scroll 0 0 #FF4300 !important;color:#FF4300 !important;}
</style>
{/literal}
<script type="text/javascript" src="{$smarty.const.RESOURCES_DOMAIN}js/regbase.js"></script>
{literal}
<script type="text/javascript">
function $rj(el) {
	if (el.nodeName) return el;
	if (typeof el === "string") return document.getElementById(el);
	return false
};
var trim = function() {
	var lSpace = /^\s\s*/,
	rSpace = /\s\s*$/;
	return function(str) {
		return str.replace(lSpace, "").replace(rSpace, "")
	}
} ();
function replaceHtml(el, html) {
	var oldEl = $rj(el);
	var newEl = oldEl.cloneNode(false);
	newEl.innerHTML = html;
	oldEl.parentNode.replaceChild(newEl, oldEl);
	return newEl
};
function replaceOuterHtml(el, html) {
	el = replaceHtml(el, "");
	if (el.outerHTML) {
		var id = el.id,
		className = el.className,
		nodeName = el.nodeName;
		el.outerHTML = "<" + nodeName + " id=\"" + id + "\" class=\"" + className + "\">" + html + "</" + nodeName + ">";
		el = $rj(id)
	} else {
		el.innerHTML = html
	};
	return el
};
function getElementsByClassName(className, tagName, parentNode) {
	var els = ($rj(parentNode) || document).getElementsByTagName(tagName || "*"),
	results = [];
	for (var i = 0; i < els.length; i++) {
		if (hasClass(className, els[i])) results.push(els[i])
	};
	return results
};
function hasClass(className, el) {
	return XRegExp.cache("(?:^|\\s)" + className + "(?:\\s|$)").test($rj(el).className)
};
function addClass(className, el) {
	el = $rj(el);
	if (!hasClass(className, el)) {
		el.className = trim(el.className + " " + className)
	}
};
function removeClass(className, el) {
	el = $rj(el);
	el.className = trim(el.className.replace(XRegExp.cache("(?:^|\\s)" + className + "(?:\\s|$)", "g"), " "))
};
function toggleClass(className, el) {
	if (hasClass(className, el)) {
		removeClass(className, el)
	} else {
		addClass(className, el)
	}
};
function swapClass(oldClass, newClass, el) {
	removeClass(oldClass, el);
	addClass(newClass, el)
};
function replaceSelection(textbox, str) {
	if (textbox.setSelectionRange) {
		var start = textbox.selectionStart,
		end = textbox.selectionEnd,
		offset = (start + str.length);
		textbox.value = (textbox.value.substring(0, start) + str + textbox.value.substring(end));
		textbox.setSelectionRange(offset, offset)
	} else if (document.selection) {
		var range = document.selection.createRange();
		range.text = str;
		range.select()
	}
};
function extend(to, from) {
	for (var property in from) to[property] = from[property];
	return to
};
function purge(d) {
	var a = d.attributes,
	i, l, n;
	if (a) {
		l = a.length;
		for (i = 0; i < l; i += 1) {
			n = a[i].name;
			if (typeof d[n] === 'function') {
				d[n] = null
			}
		}
	};
	a = d.childNodes;
	if (a) {
		l = a.length;
		for (i = 0; i < l; i += 1) {
			purge(d.childNodes[i])
		}
	}
};
var isWebKit = navigator.userAgent.indexOf("WebKit") > -1,
isIE,
isIE6 = isIE && !window.XMLHttpRequest;
var RegexPal = {
	fields: {
		search: new SmartField("search"),
		input: new SmartField("input"),
		options: {
			flags: {
				g: $rj("toolG"),
				i: $rj("toolI"),
				m: $rj("toolM"),
				s: $rj("toolS")
			},
			highlightSyntax: $rj("highSyntax"),
			highlightMatches: $rj("highMatch"),
			invertMatches: $rj("invertMatch")
		}
	}
};
extend(RegexPal,
function() {
	var f = RegexPal.fields,
	o = f.options;
	return {
		highlightMatches: function() {
			var re = {
				matchPair: /`~\{((?:[^}]+|\}(?!~`))*)\}~`((?:[^`]+|`(?!~\{(?:[^}]+|\}(?!~`))*\}~`))*)(?:`~\{((?:[^}]+|\}(?!~`))*)\}~`)?/g,
				sansTrailingAlternator: /^(?:[^\\|]+|\\[\S\s]?|\|(?=[\S\s]))*/
			};
			return function() {
				var search = String(f.search.textbox.value),
				input = String(f.input.textbox.value);
				if (XRegExp.cache('<[bB] class="?err"?>').test(f.search.bg.innerHTML) || (!search.length && !o.invertMatches.checked) || !o.highlightMatches.checked) {
					f.input.clearBg();
					return
				};
				try {
					var searchRegex = new XRegExp(re.sansTrailingAlternator.exec(search)[0], (o.flags.g.checked ? "g": "") + (o.flags.i.checked ? "i": "") + (o.flags.m.checked ? "m": "") + (o.flags.s.checked ? "s": ""))
				} catch(err) {
					f.input.clearBg();
					return
				};
				if (o.invertMatches.checked) {
					var output = ("`~{" + input.replace(searchRegex, "}~`$&`~{") + "}~`").replace(XRegExp.cache("`~\\{\\}~`|\\}~``~\\{", "g"), "")
				} else {
					var output = input.replace(searchRegex, "`~{$&}~`")
				};
				output = output.replace(XRegExp.cache("[<&>]", "g"), "_").replace(re.matchPair, "<b>$1</b>$2<i>$3</i>");
				f.input.setBgHtml(output)
			}
		} (),
		highlightSearchSyntax: function() {
			if (o.highlightSyntax.checked) {
				f.search.setBgHtml(parseRegex(f.search.textbox.value))
			} else {
				f.search.clearBg()
			}
		}
	}
} ());
var parseRegex = function() {
	var re = {
		regexToken: /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g,
		characterClassParts: /^(<opening>\[\^?)(<contents>]?(?:[^\\\]]+|\\[\S\s]?)*)(<closing>]?)$/.addFlags("k"),
		characterClassToken: /[^\\-]+|-|\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)/g,
		quantifier: /^(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??$/
	},
	type = {
		NONE: 0,
		RANGE_HYPHEN: 1,
		METACLASS: 2,
		ALTERNATOR: 3
	};
	function errorStr(str) {
		return '<b class="err">' + str + '</b>'
	};
	function getTokenCharCode(token) {
		if (token.length > 1 && token.charAt(0) === "\\") {
			var t = token.slice(1);
			if (XRegExp.cache("^c[A-Za-z]$").test(t)) {
				return "ABCDEFGHIJKLMNOPQRSTUVWXYZ".indexOf(t.charAt(1).toUpperCase()) + 1
			} else if (XRegExp.cache("^(?:x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4})$").test(t)) {
				return parseInt(t.slice(1), 16)
			} else if (XRegExp.cache("^(?:[0-3][0-7]{0,2}|[4-7][0-7]?)$").test(t)) {
				return parseInt(t, 8)
			} else if (t.length === 1 && "cuxDdSsWw".indexOf(t) > -1) {
				return false
			} else if (t.length === 1) {
				switch (t) {
				case "b":
					return 8;
				case "f":
					return 12;
				case "n":
					return 10;
				case "r":
					return 13;
				case "t":
					return 9;
				case "v":
					return 11;
				default:
					return t.charCodeAt(0)
				}
			}
		} else if (token !== "\\") {
			return token.charCodeAt(0)
		};
		return false
	};
	function parseCharacterClass(value) {
		var output = "",
		parts = re.characterClassParts.exec(value),
		parser = re.characterClassToken,
		lastToken = {
			rangeable: false,
			type: type.NONE
		},
		match,
		m;
		output += parts.closing ? parts.opening: errorStr(parts.opening);
		while (match = parser.exec(parts.contents)) {
			m = match[0];
			if (m.charAt(0) === "\\") {
				if (XRegExp.cache("^\\\\[cux]$").test(m)) {
					output += errorStr(m);
					lastToken = {
						rangeable: lastToken.type !== type.RANGE_HYPHEN
					}
				} else if (XRegExp.cache("^\\\\[dsw]$", "i").test(m)) {
					output += "<b>" + m + "</b>";
					lastToken = {
						rangeable: lastToken.type !== type.RANGE_HYPHEN,
						type: type.METACLASS
					}
				} else if (m === "\\") {
					output += errorStr(m)
				} else {
					output += "<b>" + m.replace(XRegExp.cache("[<&>]"), "_") + "</b>";
					lastToken = {
						rangeable: lastToken.type !== type.RANGE_HYPHEN,
						charCode: getTokenCharCode(m)
					}
				}
			} else if (m === "-") {
				if (lastToken.rangeable) {
					var lastIndex = parser.lastIndex,
					nextToken = parser.exec(parts.contents);
					if (nextToken) {
						var nextTokenCharCode = getTokenCharCode(nextToken[0]);
						if ((nextTokenCharCode !== false && lastToken.charCode > nextTokenCharCode) || lastToken.type === type.METACLASS || XRegExp.cache("^\\\\[dsw]$", "i").test(nextToken[0])) {
							output += errorStr("-")
						} else {
							output += "<u>-</u>"
						};
						lastToken = {
							rangeable: false,
							type: type.RANGE_HYPHEN
						}
					} else {
						if (parts.closing) {
							output += "-"
						} else {
							output += "<u>-</u>";
							break
						}
					};
					parser.lastIndex = lastIndex
				} else {
					output += "-";
					lastToken = {
						rangeable: lastToken.type !== type.RANGE_HYPHEN
					}
				}
			} else {
				output += m.replace(XRegExp.cache("[<&>]", "g"), "_");
				lastToken = {
					rangeable: (m.length > 1 || lastToken.type !== type.RANGE_HYPHEN),
					charCode: m.charCodeAt(m.length - 1)
				}
			}
		};
		return output + parts.closing
	};
	return function(value) {
		var output = "",
		capturingGroupCount = 0,
		groupStyleDepth = 0,
		openGroups = [],
		lastToken = {
			quantifiable: false,
			type: type.NONE
		},
		match,
		m;
		function groupStyleStr(str) {
			return '<b class="g' + groupStyleDepth + '">' + str + '</b>'
		};
		while (match = re.regexToken.exec(value)) {
			m = match[0];
			switch (m.charAt(0)) {
			case "[":
				output += "<i>" + parseCharacterClass(m) + "</i>";
				lastToken = {
					quantifiable: true
				};
				break;
			case "(":
				if (m.length === 2) {
					output += errorStr(m)
				} else {
					if (m.length === 1) capturingGroupCount++;
					groupStyleDepth = groupStyleDepth === 5 ? 1 : groupStyleDepth + 1;
					openGroups.push({
						index: output.length + 14,
						opening: m
					});
					output += groupStyleStr(m)
				};
				lastToken = {
					quantifiable: false
				};
				break;
			case ")":
				if (!openGroups.length) {
					output += errorStr(")");
					lastToken = {
						quantifiable: false
					}
				} else {
					output += groupStyleStr(")");
					lastToken = {
						quantifiable: !XRegExp.cache("^[=!]").test(openGroups[openGroups.length - 1].opening.charAt(2)),
						style: "g" + groupStyleDepth
					};
					groupStyleDepth = groupStyleDepth === 1 ? 5 : groupStyleDepth - 1;
					openGroups.pop()
				};
				break;
			case "\\":
				if (XRegExp.cache("^[1-9]").test(m.charAt(1))) {
					var nonBackrefDigits = "",
					num = +m.slice(1);
					while (num > capturingGroupCount) {
						nonBackrefDigits = XRegExp.cache("[0-9]$").exec(num)[0] + nonBackrefDigits;
						num = Math.floor(num / 10)
					};
					if (num > 0) {
						output += "<b>\\" + num + "</b>" + nonBackrefDigits
					} else {
						var parts = XRegExp.cache("^\\\\([0-3][0-7]{0,2}|[4-7][0-7]?|[89])([0-9]*)").exec(m);
						output += "<b>\\" + parts[1] + "</b>" + parts[2]
					}
				} else if (XRegExp.cache("^[0bBcdDfnrsStuvwWx]").test(m.charAt(1))) {
					if (XRegExp.cache("^\\\\[cux]$").test(m)) {
						output += errorStr(m);
						lastToken = {
							quantifiable: false
						};
						break
					};
					output += "<b>" + m + "</b>";
					if ("bB".indexOf(m.charAt(1)) > -1) {
						lastToken = {
							quantifiable: false
						};
						break
					}
				} else if (m === "\\") {
					output += errorStr(m)
				} else {
					output += m.replace(XRegExp.cache("[<&>]"), "_")
				};
				lastToken = {
					quantifiable: true
				};
				break;
			default:
				if (re.quantifier.test(m)) {
					if (lastToken.quantifiable) {
						var interval = XRegExp.cache("^\\{([0-9]+)(?:,([0-9]*))?").exec(m);
						if (interval && ((interval[1] > 65535) || (interval[2] && ((interval[2] > 65535) || ( + interval[1] > +interval[2]))))) {
							output += errorStr(m)
						} else {
							output += (lastToken.style ? '<b class="' + lastToken.style + '">': '<b>') + m + '</b>'
						}
					} else {
						output += errorStr(m)
					};
					lastToken = {
						quantifiable: false
					}
				} else if (m === "|") {
					if (lastToken.type === type.NONE || (lastToken.type === type.ALTERNATOR && !openGroups.length)) {
						output += errorStr(m)
					} else {
						output += openGroups.length ? groupStyleStr("|") : "<b>|</b>"
					};
					lastToken = {
						quantifiable: false,
						type: type.ALTERNATOR
					}
				} else if ("^$".indexOf(m) > -1) {
					output += "<b>" + m + "</b>";
					lastToken = {
						quantifiable: false
					}
				} else if (m === ".") {
					output += "<b>.</b>";
					lastToken = {
						quantifiable: true
					}
				} else {
					output += m.replace(XRegExp.cache("[<&>]", "g"), "_");
					lastToken = {
						quantifiable: true
					}
				}
			}
		};
		var numCharsAdded = 0;
		for (var i = 0; i < openGroups.length; i++) {
			var errorIndex = openGroups[i].index + numCharsAdded;
			output = (output.slice(0, errorIndex) + errorStr(openGroups[i].opening) + output.slice(errorIndex + openGroups[i].opening.length));
			numCharsAdded += errorStr("").length
		};
		return output
	}
} ();
function SmartField(el) {
	el = $rj(el);
	var textboxEl = el.getElementsByTagName("textarea")[0],
	bgEl = document.createElement("pre");
	textboxEl.id = el.id + "Text";
	bgEl.id = el.id + "Bg";
	el.insertBefore(bgEl, textboxEl);
	textboxEl.onkeydown = function(e) {
		SmartField.prototype._onKeyDown(e)
	};
	textboxEl.onkeyup = function(e) {
		SmartField.prototype._onKeyUp(e)
	};
	if (isIE) el.style.overflowX = "hidden";
	if (isWebKit) textboxEl.style.marginLeft = 0;
	this.field = el;
	this.textbox = textboxEl;
	this.bg = bgEl
};
extend(SmartField.prototype, {
	setBgHtml: function(html) {
		html = html.replace(XRegExp.cache("^\\n"), "\n\n");
		this.bg = replaceOuterHtml(this.bg, html + "<br>&nbsp;");
		this.setDimensions()
	},
	clearBg: function() {
		this.setBgHtml(this.textbox.value.replace(XRegExp.cache("[<&>]", "g"), "_"))
	},
	setDimensions: function() {
		this.textbox.style.width = "";
		var scrollWidth = this.textbox.scrollWidth,
		offsetWidth = this.textbox.offsetWidth;
		this.textbox.style.width = (scrollWidth === offsetWidth ? offsetWidth - 1 : scrollWidth + 8) + "px";
		this.textbox.style.height = Math.max(this.bg.offsetHeight, this.field.offsetHeight - 2) + "px"
	},
	_onKeyDown: function(e) {
		e = e || event;
		if (!this._filterKeys(e)) return false;
		var srcEl = e.srcElement || e.target;
		switch (srcEl) {
		case RegexPal.fields.search.textbox:
			setTimeout(function() {
				RegexPal.highlightSearchSyntax.call(RegexPal)
			},
			0);
			break
		};
		if (isWebKit && srcEl.selectionEnd === srcEl.value.length) {
			srcEl.parentNode.scrollTop = srcEl.scrollHeight
		};
		this._testKeyHold(e)
	},
	_onKeyUp: function(e) {
		e = e || event;
		var srcEl = e.srcElement || e.target;
		this._keydownCount = 0;
		if (this._matchOnKeyUp) {
			this._matchOnKeyUp = false;
			switch (srcEl) {
			case RegexPal.fields.search.textbox:
			case RegexPal.fields.input.textbox:
				RegexPal.highlightMatches();
				break
			}
		}
	},
	_testKeyHold: function(e) {
		var srcEl = e.srcElement || e.target;
		this._keydownCount++;
		if (this._keydownCount > 2) {
			RegexPal.fields.input.clearBg();
			this._matchOnKeyUp = true
		} else {
			switch (srcEl) {
			case RegexPal.fields.search.textbox:
			case RegexPal.fields.input.textbox:
				setTimeout(function() {
					RegexPal.highlightMatches.call(RegexPal)
				},
				0);
				break
			}
		}
	},
	_filterKeys: function(e) {
		var srcEl = e.srcElement || e.target,
		f = RegexPal.fields;
		if (this._deadKeys.indexOf(e.keyCode) > -1) return false;
		if ((e.keyCode === 9) && (srcEl === f.input.textbox || (srcEl === f.search.textbox && !e.shiftKey))) {
			if (srcEl === f.input.textbox) {
				if (e.shiftKey) {
					f.search.textbox.focus()
				} else {
					replaceSelection(srcEl, "\t");
					if (window.opera) setTimeout(function() {
						srcEl.focus()
					},
					0)
				}
			} else {
				f.input.textbox.focus()
			};
			if (e.preventDefault) e.preventDefault();
			else e.returnValue = false
		};
		return true
	},
	_matchOnKeyUp: false,
	_keydownCount: 0,
	_deadKeys: [16, 17, 18, 19, 20, 27, 33, 34, 35, 36, 37, 38, 39, 40, 44, 45, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 144, 145]
}); (function() {
	var f = RegexPal.fields,
	o = f.options;
	onresize = function(e) {
		var isIE1 = !!window.ActiveXObject;
		var isIE61 = isIE1 && !window.XMLHttpRequest;
		if (isIE61) f.input.field.style.height = Math.max((window.innerHeight || document.documentElement.clientHeight) - 310, 180) + "px";
		else f.input.field.style.height = Math.max((window.innerHeight || document.documentElement.clientHeight) - 610, 180) + "px";
		f.search.setDimensions();
		f.input.setDimensions()
	};
	onresize();
	RegexPal.highlightSearchSyntax();
	RegexPal.highlightMatches();
	for (var flag in o.flags) {
		o.flags[flag].onclick = RegexPal.highlightMatches
	};
	o.highlightSyntax.onclick = RegexPal.highlightSearchSyntax;
	o.highlightMatches.onclick = RegexPal.highlightMatches;
	o.invertMatches.onclick = RegexPal.highlightMatches;
})();
</script>
{/literal}
